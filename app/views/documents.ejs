<%- include('header') %>

<div class="container-fluid" style="margin-top:50px;">
  <div class="row">
    <div class="bg-white text-dark col-xl-8 offset-xl-2 col-lg-6 offset-lg-3 col-md-7 offset-md-3 col-sm-9 offset-sm-2">
        <br /><br />
        <h1  class="text-center"><%= title %></h1>
        <br />
        <ul>
                <li><a href="#readMe">The Vault Application</a></li>
                <ul>
                        <li><a href="#application">About Vault</a></li>
                        <li><a href="#howto">How To</a></li>
                        <ul>
                                <li><a href="#viewtestresults">View Test Results</a></li>
                                <li><a href="#exportresults">Export Test Results</a></li>
                                <li><a href="#edittestcases">Edit Test Cases</a></li>
                                <li><a href="#createtestcases">Create Test Cases</a></li>
                                <li><a href="#runtests">Run Content Tests</a></li>
                        </ul>
                        <li><a href="#templates">About Template Pages</a></li>
                        <li><a href="#tcs">About Test Cases</a></li>
                        <li><a href="#links">Useful Links</a></li>
                        <li><a href="#aboutUrls">About URLs</a></li>
                        <li><a href="#developers">Set-ups for Developers</a></li>
                </ul>
                <li><a href="#database">Database Information</a></li>
                <ul>
                        <li><a href="#testcase">The Test Case table</a></li>
                        <li><a href="#template">The Template table</a></li>
                        <li><a href="#urls">The URLs table</a></li>       
                        <li><a href="#testpass">The Test Pass table</a></li> 
                        <li><a href="#status">The Status table</a></li>   
                        <li><a href="#result">The Result table</a></li> 
                        <li><a href="#user">The User table</a></li>           
                </ul>
                <li><a href="#gherkin">Current Gherkin Definition List</a></li>
        </ul> <br /> <br />
        <div class="anchor" id="readMe"></div>
        <h2>The Vault Application</h2>
        <div class="anchor"  id="application"></div>
        <h4>About Vault</h4>
        <p>The Vault application may be used to:</p>
                <ul>
                <li>Run a Fluke site test, give that test pass a name, and view the test's status (whether in progress or recently completed).</li>
                <li>View test pass results (for completed tests only).</li>
                <li>Claim ownership of test results (for taking action on them).</li>
                <li>Export test pass results to Excel.</li>
                <li>Edit the test cases (Scenarios and Gherkin) that are run on the Fluke website pages.</li>
                <li>Delete old test passes (administrator rights required).</li>
                <li>Mark test results as unreliable (administrator rights required).</li>
                </ul>
        <div class = "anchor" id="howto"></div>
        <h4>How To</h4>
        <div class = "anchor" id="viewtestresults"></div>
        <p>View Test Results</p>
                <ol>
                        <li>Click on the Dashboard link (found in the header and on the Home page).</li>
                        <li>Select a test pass from the drop down menu at the top of the page.</li>
                        <li>Information about that test pass will display in the "Test Pass Information" section.</li>
                        Administrators will see two buttons under this section - "Delete" and "Unreliable" which affect the selected test pass.
                        <li>Beneath the test pass graph, select results by language or by template page.</li>
                        <li>On the next page, sort result further by pass/fail/skip or, depending on your earlier selection, by template or language.</li>
                        <li>The "Test Results" page now shows line by line the results for each test Case.  You may now select:</li>
                        <ul>
                                <li>Pass/Fail/Skip to sort results further.</li>
                                <li>The specific Scenario to view all results in the selected test pass for that scenario.</li>
                                <li>The URL link that the test case was run on</li>
                                <li>The "Owner" drop down allows you to assign ownership of a result for that specific scenario on that specific test pass.</li>
                                <li>The "Edit" option in the "Notes" column is useful for noting the Jira ticket related to that specific test result.</li>
                                <li>The "Export" option under the page Title allows the user to download a complete set of (Excel) results for the selected test pass.</li>
                        </ul>
                </ol>
        <div class = "anchor" id="exportresults"></div>        
        <p>Export Test Results</p>
                <ol>
                        <li>Click on the "Export Results" link in the header.</li>
                        <li>From the "Test Date" drop-down, select the test pass you want results for.</li>
                        <li>From the "Language Locale" and the "(FX) Page" drop-downs you may select "all" or a subset of test results.</li>
                        <li>Select "Export Data" for an Excel download of results.</li>
                        The Excel document will allow for filtering of results.  In order to filter results:
                        <ol>
                                <li>click on "Enable Editing."</li>
                                <li>click on "Insert" in the Ribbon.</li>
                                <li>click on "Table" in the Ribbon towards the left.</li>
                                <li>Accept the default selection, make sure "My table has headers" is checked, and click "OK."</li>
                                You may now sort the results using the drop-downs at the top of the Excel chart columns.
                        </ol>
                               
                </ol>
                <div class="text-center" ><img src="/img/exceldoc.PNG"></div>
        <div class = "anchor" id="edittestcases"></div>  
        <p>Edit Test Cases</p>
                <ol>
                        <li>Select the test case that should be edited on the Test Case Editor page.</li>
                        Administrators will have an option to delete the selected test case.
                        <li>Click "Edit Selected Test Case."</li>
                        <li>The user may now check "Function test."</li>
                        Function tests only apply to a "test" page, ensuring a functionality works which does not need testing across all pages.
                        <li>The Scenario and Gherkin may be edited (be sure to read below notes on the Scenario and Gherkin before making changes).</li>
                        <li>In the "Apply to Feature Page" section, you may edit what templates the test is applied to.</li>
                        <ul>
                                <li>Template pages that already have the test applied to them are Yellow.</li>
                                <li>Whte template pages do not currently have the test applied to them.</li>
                                <li>Clicking on a white template page will turn it green, and indicates you wish to add your test case to the template.</li>
                                <li>clicking on a yellow template will turn it red, indicating you wish to remove the test case from the template.</li>
                        </ul>
                        <li>Save edits when you are sure of your changes</li>
                </ol>
        <div class = "anchor" id="createtestcases"></div>         
        <p>Create Test Case</p>
                <ol>
                        <li>Click the "Create New Test Case" button on the Test Case Editor page.</li>
                        <li>If you will want to run tests with this test case right away, note the ID for later.</li>
                        <li>If this test is a functional test, check the box for only running this test case against a single "test" page.</li>
                        <li>Add your Scenario and Gherkin (be sure to read below notes on the Scenario and Gherkin prior to creating them).</li>
                        <li>Select the Template pages you wish to apply your test case to (see the below list for template information).</li>
                        <li>Save your test case.</li>
                        Note:
                </ol>
        <div class = "anchor" id="runtests"></div>  
        <p>Run Content Tests</p>
                <ol>
                        <li>Select the Language (Locale), Template, Test Cases and URLs you wish to test on the Run Tests page.</li>
                        <li>Click the "Run" button.</li>
                        Note: Some tests take a while to run (such as selecting all languages and all template pages).
                        The Test's status will be displayed for 10 minutes in the "Test Status" section.
                        
                </ol>
        <p>Run Functional Tests</p>
                <ol>
                        <li>Select 'Functional Test' on the Run Tests page.</li>
                        <li><i>more to come...</i></li>

                </ol>
        <p>Run Custom Tests</p>
                <ol>
                        <li><i>more to come...</i></li>
                </ol>
        <p>Test Scheduler</p>
                <ol>
                        <li><i>more to come...</i></li>
                </ol>
        <div class="anchor" id="templates"></div>
        <h4>About Template Pages</h4>
        <p>The Fluke website has been broken down into page templates for development as well as for testing.
                These page templates have been given the names "F1", "F2", "F3" etc.  When viewing the Fluke website, the template used for any specific page 
                can be found in the body tag with "template-F16" listed as a class.  Each page requirement has been written into a test called a "test case." Different 
                template pages (Fx pages) have different requirements and therefore, not all test cases apply to all pages. The templates are as follows:</p>
                <ul>
                        <li>(F1) Home Page</li>
                        <li>(F2) Product Table of Contents</li>
                        <li>(F3) Product Sub-Category</li>
                        <li>(F4) Product Display</li>
                        <li>(F5) HTML Page</li>
                        <li>(F6)</li>
                        <li>(F7) New Fluke Products</li>
                        <li>(F8) Promotions and Contests TOC</li>
                        <li>(F9) Article Table of Contents</li>
                        <li>(F10) Webcard Table of Contents</li>
                        <li>(F11) Webcard</li>
                        <li>(F12) Fluke News Table of Contents</li>
                        <li>(F13) Fluke News Sub-Category</li>
                        <li>(F14) Article</li>
                        <li>(F15) Tradeshows and Seminars</li>
                        <li>(F16) Training Library</li>
                        <li>(F17) Webinars</li>
                        <li>(F18)</li>
                        <li>(F19) Manuals</li>
                        <li>(F20) Press Releases</li>
                        <li>(F21) Safety Notices</li>
                        <li>(F22) Software Downloads</li>
                        <li>(F23) Where to Buy</li>
                        <li>(F24) Link to Offsite Location</li>
                        <li>(F25) Promotions and Contests Page</li>
                </ul>
        
        <div class="anchor" id="tcs"></div>
        <h4>About Test Cases</h4>
        <p>Tests have been written using <a target="_blank" href="http://docs.behat.org/en/v2.5/quick_intro.html">Behat</a>, with code in <a target="_blank" href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a> 
                (a human readable language) and <a target="_blank" href="http://php.net/manual/en/intro-whatis.php">PHP</a>. Each test case starts with a <a target="_blank" href="http://docs.behat.org/en/v2.5/guides/1.gherkin.html#scenarios">Scenario</a>, which is often
                copied directly from a website page requirements list. An example is "Scenario: Does page render with URL provided?" The Scenario is a note on a single line
                within the code and changing the Scenario does not affect how the code is run or the functions used for that test case. Following the Scenario is one or more lines of Gherkin
                which begin with key words <a target="_blank" href="http://docs.behat.org/en/v2.5/guides/1.gherkin.html#whens">When, Then, or Given</a>.  These key words do not matter to the code and are meant to add to the Gherkin's readability.
                Once Gherkin is written, it is linked to PHP in the background (by a developer), with each line of Gherkin calling a specific function.  When Gherkin is changed, (other than variables which are in quotes) the related PHP function must 
                be updated by a developer for the Gherkin to continue to call the correct function. In a Test Case where several lines of Gherkin are used,
                if any single line of Gherkin fails during testing, subsequent lines of Gherkin within that Test Case will be skipped.
        </p>
        <p>If the user wishes to change the Gherkin used within a Test Case, it is recommended that the user review the Gherkin that has already been created to see if the needed
                functionality already exists.  A list
                is provided <a href="#gherkin">below</a>. Reusing Gherkin that has already been created means that no additional code will be needed in order to run the test case. Changing Gherkin in any way, including just adding a space or comma,
                will cause the system to treat it as new (unknown) Gherkin.  Newly created Gherkin will "fail" during test runs until PHP has been written or updated to support it.
        </p>
        <p>An example Test Case found in the Vault database (with only one line of Gherkin):</p>
        <pre>
        Scenario: Carousel has no more than 6 Images
                Then check that there are no more than "6" "#homepage-flexslider ul li"
        </pre>
        <p>The related PHP found on the backend (notice the "* @Then..." line which links this PHP to the Gherkin above):</p>
        <pre><code>
        /**
        * Validates that there are no more than X of a generic element
        * @Then check that there are no more than :nums :elements
        */
        public function checkThatThereAreNoMoreThan($nums, $elements)
        {
                $elements = $this->getSession()->getPage()->findAll('css', $elements);
                if ($nums !=0){
                if (!$elements) {
                        throw new exception("No element found to check");
                }
                }
                echo "There are a total of " . count($elements) . " elements on this page.";
                assertLessThanOrEqual($nums, count($elements));
        }
        </code></pre>
        <br />
        <div class="anchor" id="aboutUrls"></div>
        <h4>About URLs</h4>
        <p>Several domains can be tested.  The Domain can be chosen on the Run Tests page. This will help determine what URLs are to be tested in a test pass.      
                <ul>
                        <li>https://live-igcommerce.pantheonsite.io/en-us</li>
                        <li>https://test-igcommerce.pantheonsite.io/en-us</li>
                        <li>https://dev-igcommerce.pantheonsite.io/en-us</li>
                </ul>
        </p>
        <p>
        Another domain exists which mirrors the live domain (this URL exists due to 
                <a target="_blank" href="https://support.cloudflare.com/hc/en-us/articles/205177068-Step-1-How-does-Cloudflare-work-">CloudFlare</a>).
                <ul>
                        <li>https://staging.fluke.com/en-us</li>
                </ul>
        </p>
        <p>Determining what URLs should be tested is an ongoing project.  As the Fluke web-dev team continues to improve the website,
                changes are made to the structure of the URLs.  Pages may also be added, removed from the website, or redirected.  
                <a href="https://www.deepcrawl.com/pain-point/regular-site-audit/g">DEEPCRAWL</a> information can be used to determine what
                URLs are currently on the website, however, DEEPCRAWLs do not include information on the template used for each page.  A separate
                 crawl is utilized to look at the body tags for any new website pages and determine what template that URL links to. Knowing the template then 
                 allows us to determine what test cases should be run on that page. </p>
                 <p>For additional information about the URLs being tested, please speak with your QA test developer.</p>
                 <br />
                 <br />

        </p>

        <div class="anchor" id="developers"></div>
        <h4>Set-ups for Developers</h4>
        <p>Package Manager</p>
        <ul>
                <li>NPM (npm is a package manager for the JavaScript programming language)</li>
        </ul>
        <p>Languages used in the Vault project:</p>
        <ul>
                <li>Gherkin</li>
                <li>PHP</li>
                <li>Perl</li>
                <li>HTML</li>
                <li>CSS</li>
                <li>Javascript</li>
                <li>MySQL</li>
                <li>JSON</li>
                <li>Bash programming language</li>
        </ul>
        <p>Frameworks used:</p>
        <ul>
                <li>Bootstrap 4</li>
                <li>Express.js (a web application framework for Node.js)</li>
        </ul>
        <p>Runtime environment:</p>
        <ul>
                <li>Node.js</li>
        </ul>
        <p>Libraries used:</p>
        <ul>
                <li>jQuery</li>
                <li>Sequelize</li>
        </ul>
        <p>Methodologies:</p>
        <ul>
                <li>AJAX</li>
        </ul>

        <p>Developers will need to update PHP code as web-devs change the structure of website pages, and as Vault users add additional Gherkin to the database.<br />
        If a user determines that a test is incorrectly failing, passing, or skipping, the PHP will need to be corrected so that proper results are obtained from test passes. <br />
        Below are the steps for setting up to edit PHP code.</p>
        <ul>
                <li>Download <a href="https://code.visualstudio.com/?wt.mc_id=adw-brand&gclid=Cj0KCQjw6J7YBRC4ARIsAJMXXscxjk2LNn-ZbPrfIlAgUq6ZRr7E55gFGZHet94xl0e-bXx2rt7H_FIaAiGLEALw_wcB">
                        Visual Studio Code</a> </li>
                <li><i>more to come...</i></li>
        </ul>



        <br /><br />
        <div class="anchor" id="links"></div>
        <h4 >Useful Links</h4>
        <p><a target="_blank" href="http://docs.behat.org/en/v2.5/quick_intro.html">Introduction to Behat Testing (Behat interprets Gherkin and uses PHP)</a></p>
        <p><a target="_blank" href="https://github.com/Behat/Behat">Download Behat version 3.2</a></p>
        <p><a target="_blank" href="https://github.com/cucumber/cucumber/wiki/Gherkin">About Gherkin</a></p>
        <p><a target="_blank" href="https://github.com/fluke-corporation/Vault-Web-App">Vault git-hub repository (application code)</a></p>
        <p><a target="_blank" href="https://github.com/fluke-corporation/behat_projects">behat_project git-hub repository (test case code)</a></p>
        <br /><br />
       

        <div class="anchor" id="database"></div>
        <h2>Database Information</h2>
        <p>Developers will have two databases that need to mirror each other, the database on the
                EC2 instance (http://ec2-35-168-52-214.compute-1.amazonaws.com/) and the database(s) used on local machines. 
        </p>
        <p>The database has 7 tables as seen below. These tables are used by the Vault application for running tests.</p>
        <p>When a user selects what Language and Template to test, they are narrowing down what URLs are to be tested. Selecting the domain also determines URL options. The
                user then can select the specific Test Cases that were written for the selected Template page type, narrowing down even 
                further what is to be tested. 
        </p>
        <br />
        <br />
        
        <div class="text-center" ><img src="/img/schema.PNG"></div>
        <br />
        <br />
        <div class="anchor" id="testcase"></div>
        <br />
        <h4>TestCase</h4>
        <p>[a single test that is run on a website page]<br />
                Some test cases are functional tests which means only one or a few pages need to be tested in order to know if that 
                functionality is working for all web pages. If choosing to only run functional tests, only a few specific URLs
                that are set up for running all functional tests (for that template), are tested.<br />
        <span class="font-weight-bold">TestCaseId</span> - numerical key <br />
        <span class="font-weight-bold">HashValue</span> - encrypted value used to prevent the entry of duplicative Gherkin <br />
        <span class="font-weight-bold">TestCaseDescription</span> - the scenario (note) for the test case <br />
        <span class="font-weight-bold">Live</span> - indicates if the Gherkin is being used currently <br />
        <span class="font-weight-bold">Gherkin</span> - includes the scenario with all lines of Gherkin code for each test case <br />
        <span class="font-weight-bold">IsFunctionalTest</span> - 1 for true, 0 for false, this indicates if the test tests functionality vs. content <br />
        <br />
        <div class="anchor" id="template"></div>
        <h4>Template</h4>
        <p>[a page template that specific test cases are designed for]<br />
        <span class="font-weight-bold">Id</span> - "f1", "f2", "f3" type page template key <br />
        <span class="font-weight-bold">TestCaseId</span> - a list of all the test case Ids that are run against the page template<br />
        </p>
        <br />
        <div class="anchor" id="urls"></div>
        <h4>Urls</h4>
        <p>[a page address we test]<br />
        <span class="font-weight-bold">UrlId</span> - numerical key<br />
        <span class="font-weight-bold">TemplateId</span> - the ID of the type of page template that the URL links to<br />
        <span class="font-weight-bold">Language</span> - "en-us", "en-au",(etc) language of the page the URL links to <br />
        <span class="font-weight-bold">Url</span> - the URL address<br />
        <span class="font-weight-bold">Rank</span> - intended for prioritizing URLs so that highly trafficked pages could be tested more often. Currently not used.<br />
        &emsp; F4, the template for which we have the most URLs, is set up to test 100 random F4 URLs when "all" F4 URLs are selected for testing <br />
        </p>
        <br />
        <div class="anchor" id="testpass"></div>
        <h4>TestPass</h4>
        <p>[a set of tests that are run at a specific time]<br />
        <span class="font-weight-bold">TestPassId</span> - numerical key<br />
        <span class="font-weight-bold">Template</span> - a list of the template pages that were tested in the test pass<br />
        <span class="font-weight-bold">Language</span> - a list of the languages tested in the test pass<br />
        &emsp; Note: the Template and Language selections narrow down what URLs will be tested<br />
        <span class="font-weight-bold">TestCases</span> - a list of the test case IDs that were tested in that test pass<br />
        <span class="font-weight-bold">RunDate</span> - the date and time that the test pass started (as opposed to the completion time)<br />
        <span class="font-weight-bold">UrlIds</span> - a list of the URL IDs that were tested<br />
        <span class="font-weight-bold">Domain</span> - the domain selected for testing (this helps determine which URLs are tested)<br />
        <span class="font-weight-bold">Description</span> - a note on what was tested such as "All Templates, All Languages, Limited number of URLs"<br />
        <span class="font-weight-bold">Reliable</span> - "1" for true, "0" for false, often left null.  If "0," the results have been marked as unreliable by an administrator<br />
        <span class="font-weight-bold">Note</span> - if marked unreliable, a note can be added explaining why, such as "The internet went down during testing - results unreliable"</p>
        <br />
        <div class="anchor" id="status"></div>
        <h4>Status</h4>
        <p>[data that determines if a test pass is complete or still running] <br />
                When a test is run, the Status table updates to show a start time, and an end time of 1970 until the test
                actually completes and the correct end time is entered into the database.  While the test pass is running, the status can be seen on the Test
                Status page. <br />
        <span class="font-weight-bold">TestpassId</span> - the numerical ID of the test pass that was run<br />
        <span class="font-weight-bold">RunDate</span> - the date and time on which the test was started<br />
        <span class="font-weight-bold">StartTime</span> - the date and time on which the test was started<br />
        <span class="font-weight-bold">EndTime</span> - when the test pass concluded.  <br />
        &emsp; Note: if the test pass was interrupted, an end time of January 1970 is entered into the database<br />
        &emsp; The Vault application is set to not display results on the dashboard for test passes that were stopped before completion<br />
        </p>
        <br />
        <div class="anchor" id="result"></div>
        <h4>Result</h4>
        <p>[the pass/skip/fail result of a single test]<br />
                Once a test pass is complete, results are then added to the database Result table, recording each pass, skip, and fail result.<br />
        <span class="font-weight-bold">TestCaseId</span> - the test case for which we have a test result<br />
        <span class="font-weight-bold">TestPassId</span> - the test pass that the results come from<br />
        <span class="font-weight-bold">Template</span> - the page type that the test result applies to<br />
        <span class="font-weight-bold">Language</span> - the language of the page that the result applies to<br />
        <span class="font-weight-bold">Result</span> - "pass" or "skip" or "fail"<br />
        <span class="font-weight-bold">URLs</span> - the address of the page that was tested<br />
        <span class="font-weight-bold">Output</span> - the scenario tested as well as any messages that came out of testing.<br />
        &emsp; Example: Does page render with URL provided?<br />
        &emsp; &thinsp;Result: The Response Status Code Returned a 404<br />
        <span class="font-weight-bold">RunDate</span> - the start time for when the test was run<br />
        <span class="font-weight-bold">Owner</span> - when a user selects to "own" a test result and take action on it's outcome<br />
        <span class="font-weight-bold">Notes</span> - whena  user claims ownership, they can add a note on what action they are taking for that test result<br />
        </p>
        <br />
        <div class="anchor" id="user"></div>
        <h4>User</h4>
        <p>[person who has access to the Vault application]<br />
        <span class="font-weight-bold">id</span> - numerical key<br />
        <span class="font-weight-bold">firstname</span> - first name of the user<br />
        <span class="font-weight-bold">lastname</span> - last name of the user<br />
        <span class="font-weight-bold">username</span> - the email of the user<br />
        <span class="font-weight-bold">email</span> - the email of the user<br />
        <span class="font-weight-bold">password</span> - the (encrypted) password the user set up<br />
        <span class="font-weight-bold">last_login</span> - NULL<br />
        <span class="font-weight-bold">role</span> - a numerical value with "1" for a basic user, "2" for an administrator, "3" for a developer<br />
        &emsp; NOTE: an administrator has access to additional features such as:<br />
        &emsp; &emsp; - Delete an entire test pass from the Dashboard page<br />
        &emsp; &emsp; - Delete a test case from the Test Case Editor page<br />
        &emsp; &emsp; - Mark a test pass as unreliable and add a note about it<br />
        </p>
        <br />    
        <br />

        <div class="anchor" id="gherkin"></div>
        <h2>Current Gherkin Definition List</h2>
        
        Use ctrl + f to search the below list of Gherkin code if you know the exact Gherkin. 
        Be aware that the code can be set up to accept variables such [Then|*] which can be replaced with "When" in the Gherkin
        <br />    
        <br />
        <p>A current list of Gherkin can be viewed by opening the bash shell, <br>
            go into the project file 'master_tests' (downloaded from Git) and typing the following command: vendor/bin/behat -di<br><br>
            /Vault-Web-App/behat_projects/master_tests$ vendor/bin/behat -di<br><br>
        This list includes the Gherkin added through the MINK extension and was last updated: 05.24.18</p>
        

        <pre><code>
[Then|*] skip test
        | Skip a test during testing if content or functionality is incomplete
        | at `FeatureContext::skipTest()`

[Then|*] I should see all images :element
        | Are all the images filled with actual images (non filler/broken images)?
        | at `FeatureContext::iShouldSeeAllImages()`

[Then|*] I should see an :element
        | Validates that a number of content exists
        | at `FeatureContext::valElementExists()`

[Then|*] I should see multiple :element
        | Validates that multiple elements content exists
        | at `FeatureContext::valMulipleElementsExists()`

[Then|*] I should see text :element1 and text :element2 match
        | Validates that one or multiple text elements match
        | at `FeatureContext::valTxtElemAndTxtElemMatch()`

[Then|*] I should see no more than :elemNum :elements
        | *UPDATE - include 'href' in description and use regex to update all gherkin
        |       Then I should see no more than :elemNum  href :elements
        |
        | Validates that there are no more than a number of elements shown on page
        | at `FeatureContext::noMoreThanANumberOfElements()`

[Then|*] I should see a number :elemNum of :elements
        |  UPDATE test getting the count without a loop
        |
        | Validates that there are a number of (href) elements shown on page
        | at `FeatureContext::valNumberOfHrefElementsExists()`

[Then|*] I should see a number :elemNum of text :elements
        | Validates that there are a number of (text) elements shown on page
        | at `FeatureContext::valNumberOfTextElementsExists()`

[Then|*] I should see no more than :elemNum characters on an :element
        | Validates a number of text characters in an element
        | at `FeatureContext::valNumberOfCharacters()`

[Then|*] I should see no more than :elemNum characters on multiple :element
        | Validates a number of text characters in multiple elements
        | at `FeatureContext::valNumberOfCharactersInMultiElem()`

[Then|*] I should see an :element1 for each :element2
        | Validates that each element has an element
        | at `FeatureContext::ValElem1ExistsForEachElem2()`

[Then|*] links :element1 and links :element2 match
        | Validates two lists of links
        | at `FeatureContext::ValTwoLinksMatch()`

[Then|*] links :element1 and links :element2 and links :element3 match
        | Validates three lists of links
        | at `FeatureContext::ValThreeLinksMatch()`

[Then|*] click link :element and returns a status code of 200
        | Validates that a single click event is clickable and returns a status code of 200
        | at `FeatureContext::checkSingleLinkIsClickable()`

[Then|*] click mulitple link :elements and returns a status code of 200
        | ## DO NOT USE WITH JAVASCRIPT - THIS FUNCTION USES GOUTTE DRIVER ONLY. ##
        |
        | Validates that multiple click events are clickable and returns a status code of 200
        | at `FeatureContext::checkGroupOfIsClickable()`

[Then|*] click multiple link :elements and returns a status code of 200
        | ## DO NOT USE WITH JAVASCRIPT - THIS FUNCTION USES GOUTTE DRIVER ONLY. ##
        |
        | Validates that multiple click events are clickable and returns a status code of 200
        | at `FeatureContext::checkGroupOfIsClickable()`

[Then|*] link :elements open with correct target
        | Do all links open with the correct target?
        | at `FeatureContext::validateTargetAttribute()`

[Then|*] check that there are no more than :nums :elements
        | Validates that there are no more than X of a generic element
        | at `FeatureContext::checkThatThereAreNoMoreThan()`

[Then|*] check multiple :elements should have class :class
        | at `FeatureContext::checkMultipleShouldHaveClass()`

[Then|*] if there are less than :num :element1 then there are no :element2
        | Pagination Elements do not appear if there are less than 10 Articles on the first page, but do appear if there is more than 10
        | at `FeatureContext::ifThereAreLessThanThenThereAreNo()`

[Then|*] check :element elements in correct language
        | Validates that text elements are in the correct language by searching a database or Google language detect
        | at `FeatureContext::checkElementsInCorrectLanguage()`

[Then|*] I should see that text :elements with attribute :attribute will match the correct language
        | Validates that an elements text based on its attribute is in the correct language a database or Google language detect
        | at `FeatureContext::checkAttributeTextInCorrectLanguage()`
        </code></pre>



        <button id="showButton" onclick="showMore('showMoreSection', 'showButton')">See More</button>





       <div id="showMoreSection" style="display:none"> 
               
               <button id="hideButton" onclick="showLess('showMoreSection', 'showButton')">See Less</button>
        
        <pre><code>
[Then|*] check :text is in correct language
        | Compares the url language locale to &lt;html lang&gt; and
        | uses langid to validate language with a provided
        | text snippet.
        | ******* NOTE - IGNORE GHERKIN *******
        | at `FeatureContext::checkTextIsInCorrectLanguage()`

[Then|*] I should see that text :element translation will match the correct language found in database
        | Queries database - "translations" for translated word found on webpage:
        | Validates that a text element is the correct text translation in any language by searching the "translations" database
        | ******* NOTE - IGNORE GHERKIN *******
        | at `FeatureContext::dbDetectLangByText()`

[Then|*] I should see that text :elements with attributes
        | Queries database - "translations" for translated word found on webpage:
        | Validates that an elements text based on its attribute is in the correct language by searching the "translations" database
        | ******* NOTE - IGNORE GHERKIN *******
        | at `FeatureContext::dbDetectLangByAttrib()`

[Then|*] :firstElement attribute :attributeOfFirstElement matches :secondElement attribute :attributeOfSecondElement
        | NOTE - can fail if unequal number of elements compared   - checks to see if two elements have coordinating attributes
        | at `FeatureContext::attributeMatchesAttribute()`

[Then|*] the :thumbnail should become :class1 and the large matching :image above becomes :class2
        | NOTE: checks if each element X is clicked (and gets class Q) that corresponding element Y gains class R
        |  WARNING: If an image contains brightcove image source, then video must be checked manually
        |  TODO: hard code working solution for videos
        | at `FeatureContext::thumbnailandCarouselMatching()`

[Then|*] for each :image the height and width are at least :heightY by :widthX
        | at `FeatureContext::forEachTheHeightAndWidthAreAtLeastBy()`

[Then|*] I should see no more than :elemNum characters on any :element1
        | REVIEWS ALL ELEMENT-Xs FOR CHARACTER COUNT
        | at `FeatureContext::iShouldSeeNoMoreThanCharactersOnAny()`

[Then|*] if the :page1 page has :element the current page will have :element2
        | [Optional] Safety Recall notification only appears if there is an active Safety Recall published on the Safety Notices page
        | at `FeatureContext::ifThePageHasTheCurrentPageWillHave()`

[Then|*] vardump :arg1
        | at `FeatureContext::vardump()`

[Then|*] every :num seconds the next :element changes attribute :attribute in style array :arrayNum
        | Before clicking any slide, the slides automatically cycle every 5 seconds - looks to see if the X attribute (which is $arrayNum in the style array) changes every Y seconds
        | at `FeatureContext::everySecondsTheNextChangesAttributeInStyleArray()`

[Then|*] the :elements with :attribute should contain :string
        | at `FeatureContext::theWithShouldContain()`

[Then|*] check :elements1 have a match in :elements2
        | Checks to see if elements in first array match elements in second array
        | All elements in first array must have a match in second array to pass
        | at `FeatureContext::checkFImagesAgainstFTopNav()`

[Then|*] The image link :arg1 should match the image text link :arg2 and the left nav text link :arg3
        | Checks if the image link matches the image text link and the left navigation text link
        | at `FeatureContext::checkLinksImgAndImgTxtAndLeftNavTxt()`

[Then|*] check :element element
        | at `FeatureContext::checkElement()`

[Then|*] :element is an image
        | Can make this global - used in F1 too
        | at `FeatureContext::isAnImage()`

[When|*] /^(?:|I )follow css "(?P&lt;link&gt;(?:[^"]|\\")*)"$/
        | Clicks link with specified css selector
        | Example: When I follow ".class a"
        | Example: And I follow ""
        | at `FeatureContext::clickCssLink()`

[Then|*] print :element element attribute :attribute
        | at `FeatureContext::printElementAttribute()`

[Then|*] print :element element attributes :attribute
        | at `FeatureContext::printElementAttributes()`

[Then|*] the :element element should be title cased
        | Checks to see if element is title cased
        | - Checks first word and letter only to see if uppercase.
        | at `FeatureContext::elementshouldbetitlecased()`

[Then|*] check multiple :elements should be title cased
        | Checks to see if multiple element are title cased
        | - Checks first word and letter only to see if uppercase.
        | *@Then check multiple :elements should be title cased
        | at `FeatureContext::multipleelementshouldbetitlecased()`

[Then|*] check :element is not empty
        | at `FeatureContext::checkIsNotEmpty()`

[Then|*] check multiple :elements are not empty
        | at `FeatureContext::checkmultipleNotEmpty()`

[Then|*] the page title and h1 should be similar
        | Compares the h1 and title - should be equal.
        | Will Also fail if h1 is empty
        | at `FeatureContext::thePageTitleAndH1Similar()`

[Then|*] I should see :element1 with content :element2
        | Validates if an element exists then there is content
        | at `FeatureContext::ValTabExistWithContent()`

[Then|*] I should see total tab :element1 match the total page :element2
        | Validates that each tab total products matches the total products listed
        | at `FeatureContext::valTabTotNumMatchesTotNumProdShown()`

[Then|*] check if :elements1 have associated :elements2
        | at `FeatureContext::checkAssociatedElements()`

[Then|*] check :arg1 single icons only
        | at `FeatureContext::checkSingleIconsOnly()`

[Then|*] check :elements for element with :attribute having :string
        | at `FeatureContext::checkForElementWithHaving()`

[Then|*] check :element is visible
        | at `FeatureContext::checkisvisiblestandard()`

[Then|*] I check all the links :element1 go to the correct item
        | IN PROGRESS _ COULD NOT YET TEST (elements not found)
        | at `FeatureContext::iCheckAllTheLinksGoToTheCorrectItem()`

[Then|*] in the string :string the first number is :num and the second number is the total number of :element1
        | Are the numbers in the line  'Showing x of xx products' correct?
        | at `FeatureContext::inTheStringTheFirstNumberIsAndTheSecondNumberIsTheTotalNumberOf()`

[Then|*] if there are no :element1 then there is no :title
        | If there are no related products there is no related title
        | at `FeatureContext::ifThereAreNoThenThereIsNo()`

[Then|*] check related projects forward carousel?
        | at `FeatureContext::checkRelatedProjectsForwardCarousel()`

[Then|*] check related projects back carousel?
        | at `FeatureContext::checkRelatedProjectsbackCarousel()`

[Then|*] Check parent element :element1 number matches :element2 amount of children
        | at `FeatureContext::checkParentElementNumHasCorrectNumOfChild()`

[Then|*] multiple :elements with :attribute should contain :string
        | Also used on F1 (Make Global)
        | at `FeatureContext::checkElementsHaveClassWithString()`

[Then|*] check if not :locale
        | at `FeatureContext::checkIfNot()`

[Then|*] check if only in :locale :elements :attribute string contains :string
        | at `FeatureContext::checkIfIdHasStringBasedOnLocale()`

[Then|*] check if parent :arg1 has children :arg2
        | Check to see if there are
        | at `FeatureContext::checkIfParentHasChildren()`

[Then|*] if :num :elements I should not see :element2
        | On product page, checks that no thumbnails are present if only one image.
        | at `FeatureContext::ifOneImageNoThumbnails2()`

[Then|*] cycle through :elements and only :num should have :class
        | at `FeatureContext::cycleThroughAndOnlyShouldHave()`

[Then|*] Check if :element element displays not found
        | at `FeatureContext::checkIfElementDisplaysNotFound()`

[Then|*] the thumbnail should load the large matching image above
        | Current strategy is to click on each li and confirm that the img has an img.flex-active class
        | at `FeatureContext::thumbnailLaodMatching()`

[When|*] /^wait (\d+) seconds?$/
        | at `FeatureContext::waitSeconds()`

[Then|*] compare the url with the :arg1 breadcrumb element
        | at `FeatureContext::compareUrlAgainstBreadcrumb()`

[Then|*] I check the link from css :element is correct
        | at `FeatureContext::iShouldSeeTheCorrectPage()`

[Given|*] the :element element is on the page
        | at `FeatureContext::theElementIsOnThePage()`

[Then|*] If there are :charNUms characters in :element1 :element2 exists
        | at `FeatureContext::ifCharactersElementExists()`

[Then|*] check the :imgElements forward :button on the carousel
        | at `FeatureContext::checkTheforwardCarousel()`

[Then|*] check the :imgElements back :button on the carousel
        | at `FeatureContext::checkThebackCarousel()`

[Then|*] click on :arg1 and check :arg2 expanded
        | at `FeatureContext::clickOnAndCheckExpanded()`

[Then|*] click on :arg1 and check :arg2 not expanded
        | at `FeatureContext::clickOnAndCheckNotExpanded()`

[Then|*] click text element :element has changed and is not empty
        | at `FeatureContext::checkTextElementHasChanged()`

[Then|*] click on :element
        | at `FeatureContext::clickOn()`

[Then|*] check if :locale only shows :element
        | at `FeatureContext::checkIfOnlyShows()`

[Then|*] check :element is not a link
        | at `FeatureContext::checkIsNotLink()`

[Then|*] check link :element language locale
        | *@Then check link :element language locale
        | at `FeatureContext::checkLinkLocale()`

[Then|*] check if less than :num of :elements is visible fail
        | at `FeatureContext::checkIsLessThanNumVisiblefail()`

[Then|*] check if less than :num of :elements is visible skip
        | at `FeatureContext::checkIsLessThanNumVisibleSkip()`

[Then|*] check if more than :num of :elements is visible skip
        | at `FeatureContext::checkIsmoreThanNumVisibleSkip()`

[Then|*] check :element is visible skip
        | at `FeatureContext::checkIsVisible()`

[Then|*] check :element is not visible skip
        | at `FeatureContext::checkIsNotVisible()`

[Then|*] check :element is visible fail
        | at `FeatureContext::checkIsVisiblefail()`

[Then|*] check :element is not visible fail
        | at `FeatureContext::checkIsNotVisiblefail()`

[Then|*] check :element has content
        | at `FeatureContext::checkHasContent()`

[Then|*] check :element anchor link
        | Checks the anchor link to ensure that an anchor section tag exists
        | at `FeatureContext::checkAnchorLink()`

[When|*] I click on :element
        | at `FeatureContext::iClickOn()`

[Then|*] check that the :element :attribute is :quality else skip
        |    ****** THIS FUNCTION SKIPS NEXT STEP IF FAILS
        | at `FeatureContext::checkThatTheIsElseSkip()`

[Then|*] check that the :element :attribute is :quality
        | Move to Global when f4_base.feature is updated (can use in F1 as well)
        | at `FeatureContext::checkThatTheIs()`

[Then|*] click multiple :elements1 and check multiple :elements2 expanded
        | Click on the element to determine if element to expand has style of display:block
        | at `FeatureContext::clickMultipleExpanded()`

[Then|*] click multiple :elementsToClick and check multiple :elementsToCollapse collapsed
        | Click on the element to determine if element to expand has style of display:block
        | at `FeatureContext::clickMultipleCollapsed()`

[Then|*] The parent elements should all be :element
        | Are all of the display title links h2 elements? - (F7)
        | at `FeatureContext::valParentElem()`

[Then|*] I should see all elements :element1 parents are :element2 elements
        | Are all of the display title links h2 elements? - (F7)
        | at `FeatureContext::f7FunctionWorkInProgress_rev2()`

[Then|*] check if elements :elements1 match the elements :elements2
        | Validates that the elements in one array match the elements in the second array
        | at `FeatureContext::valImageLinksMatchTopNavLinks()`

[Then|*] the page :element1 and :element2 should be the same
        | Does the page title and H1 match? F9
        | Will Also fail if h1 is empty
        | Then the page title and h1 should be similar
        | at `FeatureContext::pageTitleAndH1Match_F9()`

[Then|*] I should see that a Call for Assistance :element1 exists
        | Validates that the Call for Assistance exists on page (en-us only) F11
        | at `FeatureContext::callForAssistanceExists_F11()`

[Then|*] click pagination link :element and returns a status code of 200
        | DO NOT USE - WORK IN PROGRESS
        | Validates that Pagination links are clickable and returns a status code of 200
        | at `FeatureContext::checkPaginationLinkIsClickable()`

[Then|*] check multiple :elements are clickable
        | at `FeatureContext::checkMultipleAreClickable()`

[Then|*] check that the direct parent of :element1 element is an :element2 element
        | at `FeatureContext::checkThatDirectIsAnElement()`

[Then|*] the :element1 with :class should contain :element2 string
        | at `FeatureContext::theWithShouldContainString()`

[Then|*] I should not see dates :element older than current date v2
        | Validates that Live webinars will not show if the dates are older than current date
        | at `FeatureContext::valDatesNotOlderThanCurrentDate2()`

[Then|*] I should see multiple dates :element sorted in order on Tradeshows and seminars
        | Sort by Date - "Thursday, February 1, 2018 - 08:00'
        | Validates that the sort order for Tradeshows and seminars is done by date ascending
        | at `FeatureContext::valMuliDatesSortedInOrder2()`

[Then|*] check :element1" is not on page I should see :element2
        | Checks to see that an element is on page with text if another element is not on page
        |
        | *@Then check :element1" is not on page I should see :element2
        | at `FeatureContext::checkElementNotOnPageThenShouldSee()`

[Then|*] there are :num :elements on the page with the names of :names in order
        | 4 tabs are on page, named in the following order: Videos, App Notes, Demos, Documents
        | at `FeatureContext::thereAreOnThePageWithTheNamesOfInOrder()`

[Then|*] click link :element
        | just click something
        | at `FeatureContext::clickLink2()`

[Then|*] when I click on each :pagination, there are no more than :num :articles items without style :style
        | This is no longer working due to how the page was restructured - MAY END UP DELETING THIS IF I CAN'T USE IT (3.8.18)
        | No individual page has more than 10 Articles (when I click on each pagination, there is no more than x that do NOT have -display:none;)
        | at `FeatureContext::whenIClickOnEachThereAreNoMoreThanItemsWithoutStyle()`

[Then|*] when I click on the :next Next Button for each :pagination, there are no more than :num :articles that are not :attribute1 or :attribute2
        | Scenario: No individual page has more than 10 Articles (Videos)
        | Then when clicking the :next next button, each page is tested to make sure total items styled with display:none; or display: none; leave 10 or less elements without a style
        | at `FeatureContext::whenIClickOnTheNextButtonForEachThereAreNoMoreThanThatAreNotOr()`

[Then|*] :element contains the word :string in its :attribute
        | at `FeatureContext::containsTheWordInIts()`

[Then|*] click all :element
        | at `FeatureContext::clickAll()`

[Then|*] check all :element
        | This will check the element IF IT IS VISIBLE! - test for visiblity where needed.
        | at `FeatureContext::checkAll()`

[Then|*] uncheck all :element
        | at `FeatureContext::uncheckAll()`

[Then|*] if there are more than :num :articles then I should see an :next
        | at `FeatureContext::ifThereAreMoreThanThenIShouldSeeAn()`

[Then|*] if there are more than :num :articles I can click on :page2 and see a :previousButton
        | at `FeatureContext::ifThereAreMoreThanICanClickOnAndSeeA()`

[Then|*] I cannot click on :element
        | at `FeatureContext::iCannotClickOn()`

[Then|*] if there are more than :num :articles I can click on :page2 and then click on a :page1 and then see a :activePage
        |  'First Page' button takes the user to the first page when clicked
        | at `FeatureContext::ifThereAreMoreThanICanClickOnAndThenClickOnAAndThenSeeA()`

[Then|*] if there are more than :num :articles then when I click on the last :page there is a :next
        | at `FeatureContext::ifThereAreMoreThanThenWhenIClickOnTheLastThereIsA()`

[Then|*] if there are more than :arg1 :arg2 I can click on :arg3 and then click on a :arg4 and then see a :arg5 for the last page
        |     ONLY WRITE THIS IF THEY ADD 'LAST PAGE' ELEMENTS THAT NEED FURTHER TESTING (UNLIKELY)
        | at `FeatureContext::ifThereAreMoreThanICanClickOnAndThenClickOnAAndThenSeeAForTheLastPage()`

[Then|*] I should not see an :element
        | at `FeatureContext::iShouldNotSeeAn()`

[Then|*] I should see live webinar text :element match language list
        | Validates that Tab 1 is title "Live Webinars" after translation
        | at `FeatureContext::valliveWebinarTxtMatchLangList()`

[Then|*] I should see On-Demand Webinar text :element match language list
        | Validates that Tab 2 is title "On-Demand Webinars" after translation
        | at `FeatureContext::valOnDemandWebinarTxtMatchLangList()`

[Then|*] I should see a column element :element labled :elemText
        | Validates that there is a webinar column labled
        | at `FeatureContext::valElemTextInColumnExists()`

[Then|*] I should see multiple lists :element in alphabetical order
        | Make Global - used in F19 as well
        | Sort text Alphabetically -
        | Validates that On-Demand Webinars are listed in alphabetical order under the webinar name
        | at `FeatureContext::valElemAreListedAlphabetically()`

[Then|*] I should only see text :element1 if text exits :element2
        | THIS SCRIPT NEEDS MORE TESTING EXAMPLES - MAY NOT WORK PROPERLY
        | Validates that the category filter contains all the categories that appear in the Webinar Type column
        | at `FeatureContext::valTxtInElem1ExistsIfTxtInElem2Exists()`

[Then|*] If an :element is not visible I should see a message
        | Validates that the table in Live Webinars is replaced with "No events scheduled, check back soon." if there are no events
        | at `FeatureContext::valIfElementIsHiddenShowMsg()`

[Then|*] I should see multiple dates :element sorted in order
        | Sort by Date - "MON D , YEAR 00:00 AM PST'
        | Validates that the sort order for Live webinars is done by date ascending
        | at `FeatureContext::valMuliDatesSortedInOrder()`

[Then|*] I should not see dates :element older than current date
        | Validates that Live webinars will not show if the dates are older than current date
        | at `FeatureContext::valDatesNotOlderThanCurrentDate()`

[Then|*] I should see each CTA :element with :elemText text
        | Validates that each CTA button for the On-demand webinar has a label of "Watch Now"
        | at `FeatureContext::valCTAHasWatchNowText()`

[Then|*] all :elem1 have a :structure date in its text
        | Checks to see if a date is in the text.  See formula for Gherkin needed for $structure variable
        | at `FeatureContext::allHaveADateInItsText()`

[Then|*] each :element has taxonomy
        | Each search result shows it's taxonomy - This will fail if there is not text after the second "|"" in the date-type div
        | at `FeatureContext::eachHasTaxonomy()`

[Then|*] check and uncheck all :element
        | *This tests that each dynamically created checkbox can be clicked, then unclicked
        | at `FeatureContext::checkAndUncheckAll()`

[When|*] the user clicks a dynamically created :element1 then the page will show dynamically created :element2
        |  Checks that when a dynamically created element is clicked, dynamically created content then exists
        | at `FeatureContext::theUserClicksADynamicallyCreatedThenThePageWillShowDynamicallyCreated()`

[Then|*] maximize the window
        | at `FeatureContext::maximizeTheWindow()`

[Then|*] check :element has text that contains :text
        | at `FeatureContext::checkHasTextThatContains()`

[Then|*] the number of results for link :link matches the number shown at :label
        | at `FeatureContext::theNumberOfResultsForLinkMatchesTheNumberShownAt()`

[Then|*] check :element :attribute is not empty
        | at `FeatureContext::checkAttributeIsNotEmpty()`

[Then|*] I should see an :element1 and at least one :element2
        | Validates that each h2 element has at least one press release link
        | at `FeatureContext::ValElem1ExistsAndAnElem2Exists()`

[Then|*] I should see current text :element match language list
        | Validates that Tab 1 is title "Current" after translation
        | at `FeatureContext::valCurrentTxtMatchLangList()`

[Then|*] I should see archive text :element match language list
        | Validates that Tab 2 is title "Archive" after translation
        | at `FeatureContext::valArchiveTxtMatchLangList()`

[Then|*] I should see CTA text :element match language list
        | Validates that the CTA text is labeled "Search" is a match in all lanuages
        | at `FeatureContext::valCTATxtMatchLangList()`

[Then|*] check :arg1 for attribute with :arg2 having regex match :arg3
        | at `FeatureContext::checkForElementWithHavingRegexMatch()`

[Given|*] /^(?:|I )am on (?:|the )homepage$/
        | Opens homepage
        | Example: Given I am on "/"
        | Example: When I go to "/"
        | Example: And I go to "/"
        | at `FeatureContext::iAmOnHomepage()`

[When|*] /^(?:|I )go to (?:|the )homepage$/
        | Opens homepage
        | Example: Given I am on "/"
        | Example: When I go to "/"
        | Example: And I go to "/"
        | at `FeatureContext::iAmOnHomepage()`

[Given|*] /^(?:|I )am on "(?P&lt;page&gt;[^"]+)"$/
        | Opens specified page
        | Example: Given I am on "http://batman.com"
        | Example: And I am on "/articles/isBatmanBruceWayne"
        | Example: When I go to "/articles/isBatmanBruceWayne"
        | at `FeatureContext::visit()`

[When|*] /^(?:|I )go to "(?P&lt;page&gt;[^"]+)"$/
        | Opens specified page
        | Example: Given I am on "http://batman.com"
        | Example: And I am on "/articles/isBatmanBruceWayne"
        | Example: When I go to "/articles/isBatmanBruceWayne"
        | at `FeatureContext::visit()`

[When|*] /^(?:|I )reload the page$/
        | Reloads current page
        | Example: When I reload the page
        | Example: And I reload the page
        | at `FeatureContext::reload()`

[When|*] /^(?:|I )move backward one page$/
        | Moves backward one page in history
        | Example: When I move backward one page
        | at `FeatureContext::back()`

[When|*] /^(?:|I )move forward one page$/
        | Moves forward one page in history
        | Example: And I move forward one page
        | at `FeatureContext::forward()`

[When|*] /^(?:|I )press "(?P&lt;button&gt;(?:[^"]|\\")*)"$/
        | Presses button with specified id|name|title|alt|value
        | Example: When I press "Log In"
        | Example: And I press "Log In"
        | at `FeatureContext::pressButton()`

[When|*] /^(?:|I )follow "(?P&lt;link&gt;(?:[^"]|\\")*)"$/
        | Clicks link with specified id|title|alt|text
        | Example: When I follow "Log In"
        | Example: And I follow "Log In"
        | at `FeatureContext::clickLink()`

[When|*] /^(?:|I )fill in "(?P&lt;field&gt;(?:[^"]|\\")*)" with "(?P&lt;value&gt;(?:[^"]|\\")*)"$/
        | Fills in form field with specified id|name|label|value
        | Example: When I fill in "username" with: "bwayne"
        | Example: And I fill in "bwayne" for "username"
        | at `FeatureContext::fillField()`

[When|*] /^(?:|I )fill in "(?P&lt;field&gt;(?:[^"]|\\")*)" with:$/
        | Fills in form field with specified id|name|label|value
        | Example: When I fill in "username" with: "bwayne"
        | Example: And I fill in "bwayne" for "username"
        | at `FeatureContext::fillField()`

[When|*] /^(?:|I )fill in "(?P&lt;value&gt;(?:[^"]|\\")*)" for "(?P&lt;field&gt;(?:[^"]|\\")*)"$/
        | Fills in form field with specified id|name|label|value
        | Example: When I fill in "username" with: "bwayne"
        | Example: And I fill in "bwayne" for "username"
        | at `FeatureContext::fillField()`

[When|*] /^(?:|I )fill in the following:$/
        | Fills in form fields with provided table
        | Example: When I fill in the following"
        |              | username | bruceWayne |
        |              | password | iLoveBats123 |
        | Example: And I fill in the following"
        |              | username | bruceWayne |
        |              | password | iLoveBats123 |
        | at `FeatureContext::fillFields()`

[When|*] /^(?:|I )select "(?P&lt;option&gt;(?:[^"]|\\")*)" from "(?P&lt;select&gt;(?:[^"]|\\")*)"$/
        | Selects option in select field with specified id|name|label|value
        | Example: When I select "Bats" from "user_fears"
        | Example: And I select "Bats" from "user_fears"
        | at `FeatureContext::selectOption()`

[When|*] /^(?:|I )additionally select "(?P&lt;option&gt;(?:[^"]|\\")*)" from "(?P&lt;select&gt;(?:[^"]|\\")*)"$/
        | Selects additional option in select field with specified id|name|label|value
        | Example: When I additionally select "Deceased" from "parents_alive_status"
        | Example: And I additionally select "Deceased" from "parents_alive_status"
        | at `FeatureContext::additionallySelectOption()`

[When|*] /^(?:|I )check "(?P&lt;option&gt;(?:[^"]|\\")*)"$/
        | Checks checkbox with specified id|name|label|value
        | Example: When I check "Pearl Necklace"
        | Example: And I check "Pearl Necklace"
        | at `FeatureContext::checkOption()`

[When|*] /^(?:|I )uncheck "(?P&lt;option&gt;(?:[^"]|\\")*)"$/
        | Unchecks checkbox with specified id|name|label|value
        | Example: When I uncheck "Broadway Plays"
        | Example: And I uncheck "Broadway Plays"
        | at `FeatureContext::uncheckOption()`

[When|*] /^(?:|I )attach the file "(?P&lt;path&gt;[^"]*)" to "(?P&lt;field&gt;(?:[^"]|\\")*)"$/
        | Attaches file to field with specified id|name|label|value
        | Example: When I attach "bwayne_profile.png" to "profileImageUpload"
        | Example: And I attach "bwayne_profile.png" to "profileImageUpload"
        | at `FeatureContext::attachFileToField()`

[Then|*] /^(?:|I )should be on "(?P&lt;page&gt;[^"]+)"$/
        | Checks, that current page PATH is equal to specified
        | Example: Then I should be on "/"
        | Example: And I should be on "/bats"
        | Example: And I should be on "http://google.com"
        | at `FeatureContext::assertPageAddress()`

[Then|*] /^(?:|I )should be on (?:|the )homepage$/
        | Checks, that current page is the homepage
        | Example: Then I should be on the homepage
        | Example: And I should be on the homepage
        | at `FeatureContext::assertHomepage()`

[Then|*] /^the (?i)url(?-i) should match (?P&lt;pattern&gt;"(?:[^"]|\\")*")$/
        | Checks, that current page PATH matches regular expression
        | Example: Then the url should match "superman is dead"
        | Example: Then the uri should match "log in"
        | Example: And the url should match "log in"
        | at `FeatureContext::assertUrlRegExp()`

[Then|*] /^the response status code should be (?P&lt;code&gt;\d+)$/
        | Checks, that current page response status is equal to specified
        | Example: Then the response status code should be 200
        | Example: And the response status code should be 400
        | at `FeatureContext::assertResponseStatus()`

[Then|*] /^the response status code should not be (?P&lt;code&gt;\d+)$/
        | Checks, that current page response status is not equal to specified
        | Example: Then the response status code should not be 501
        | Example: And the response status code should not be 404
        | at `FeatureContext::assertResponseStatusIsNot()`

[Then|*] /^(?:|I )should see "(?P&lt;text&gt;(?:[^"]|\\")*)"$/
        | Checks, that page contains specified text
        | Example: Then I should see "Who is the Batman?"
        | Example: And I should see "Who is the Batman?"
        | at `FeatureContext::assertPageContainsText()`

[Then|*] /^(?:|I )should not see "(?P&lt;text&gt;(?:[^"]|\\")*)"$/
        | Checks, that page doesn't contain specified text
        | Example: Then I should not see "Batman is Bruce Wayne"
        | Example: And I should not see "Batman is Bruce Wayne"
        | at `FeatureContext::assertPageNotContainsText()`

[Then|*] /^(?:|I )should see text matching (?P&lt;pattern&gt;"(?:[^"]|\\")*")$/
        | Checks, that page contains text matching specified pattern
        | Example: Then I should see text matching "Batman, the vigilante"
        | Example: And I should not see "Batman, the vigilante"
        | at `FeatureContext::assertPageMatchesText()`

[Then|*] /^(?:|I )should not see text matching (?P&lt;pattern&gt;"(?:[^"]|\\")*")$/
        | Checks, that page doesn't contain text matching specified pattern
        | Example: Then I should see text matching "Bruce Wayne, the vigilante"
        | Example: And I should not see "Bruce Wayne, the vigilante"
        | at `FeatureContext::assertPageNotMatchesText()`

[Then|*] /^the response should contain "(?P&lt;text&gt;(?:[^"]|\\")*)"$/
        | Checks, that HTML response contains specified string
        | Example: Then the response should contain "Batman is the hero Gotham deserves."
        | Example: And the response should contain "Batman is the hero Gotham deserves."
        | at `FeatureContext::assertResponseContains()`

[Then|*] /^the response should not contain "(?P&lt;text&gt;(?:[^"]|\\")*)"$/
        | Checks, that HTML response doesn't contain specified string
        | Example: Then the response should not contain "Bruce Wayne is a billionaire, play-boy, vigilante."
        | Example: And the response should not contain "Bruce Wayne is a billionaire, play-boy, vigilante."
        | at `FeatureContext::assertResponseNotContains()`

[Then|*] /^(?:|I )should see "(?P&lt;text&gt;(?:[^"]|\\")*)" in the "(?P&lt;element&gt;[^"]*)" element$/
        | Checks, that element with specified CSS contains specified text
        | Example: Then I should see "Batman" in the "heroes_list" element
        | Example: And I should see "Batman" in the "heroes_list" element
        | at `FeatureContext::assertElementContainsText()`

[Then|*] /^(?:|I )should not see "(?P&lt;text&gt;(?:[^"]|\\")*)" in the "(?P&lt;element&gt;[^"]*)" element$/
        | Checks, that element with specified CSS doesn't contain specified text
        | Example: Then I should not see "Bruce Wayne" in the "heroes_alter_egos" element
        | Example: And I should not see "Bruce Wayne" in the "heroes_alter_egos" element
        | at `FeatureContext::assertElementNotContainsText()`

[Then|*] /^the "(?P&lt;element&gt;[^"]*)" element should contain "(?P&lt;value&gt;(?:[^"]|\\")*)"$/
        | Checks, that element with specified CSS contains specified HTML
        | Example: Then the "body" element should contain "style=\"color:black;\""
        | Example: And the "body" element should contain "style=\"color:black;\""
        | at `FeatureContext::assertElementContains()`

[Then|*] /^the "(?P&lt;element&gt;[^"]*)" element should not contain "(?P&lt;value&gt;(?:[^"]|\\")*)"$/
        | Checks, that element with specified CSS doesn't contain specified HTML
        | Example: Then the "body" element should not contain "style=\"color:black;\""
        | Example: And the "body" element should not contain "style=\"color:black;\""
        | at `FeatureContext::assertElementNotContains()`

[Then|*] /^(?:|I )should see an? "(?P&lt;element&gt;[^"]*)" element$/
        | Checks, that element with specified CSS exists on page
        | Example: Then I should see a "body" element
        | Example: And I should see a "body" element
        | at `FeatureContext::assertElementOnPage()`

[Then|*] /^(?:|I )should not see an? "(?P&lt;element&gt;[^"]*)" element$/
        | Checks, that element with specified CSS doesn't exist on page
        | Example: Then I should not see a "canvas" element
        | Example: And I should not see a "canvas" element
        | at `FeatureContext::assertElementNotOnPage()`

[Then|*] /^the "(?P&lt;field&gt;(?:[^"]|\\")*)" field should contain "(?P&lt;value&gt;(?:[^"]|\\")*)"$/
        | Checks, that form field with specified id|name|label|value has specified value
        | Example: Then the "username" field should contain "bwayne"
        | Example: And the "username" field should contain "bwayne"
        | at `FeatureContext::assertFieldContains()`

[Then|*] /^the "(?P&lt;field&gt;(?:[^"]|\\")*)" field should not contain "(?P&lt;value&gt;(?:[^"]|\\")*)"$/
        | Checks, that form field with specified id|name|label|value doesn't have specified value
        | Example: Then the "username" field should not contain "batman"
        | Example: And the "username" field should not contain "batman"
        | at `FeatureContext::assertFieldNotContains()`

[Then|*] /^(?:|I )should see (?P&lt;num&gt;\d+) "(?P&lt;element&gt;[^"]*)" elements?$/
        | Checks, that (?P&lt;num&gt;\d+) CSS elements exist on the page
        | Example: Then I should see 5 "div" elements
        | Example: And I should see 5 "div" elements
        | at `FeatureContext::assertNumElements()`

[Then|*] /^the "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" checkbox should be checked$/
        | Checks, that checkbox with specified id|name|label|value is checked
        | Example: Then the "remember_me" checkbox should be checked
        | Example: And the "remember_me" checkbox is checked
        | at `FeatureContext::assertCheckboxChecked()`

[Then|*] /^the "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" checkbox is checked$/
        | Checks, that checkbox with specified id|name|label|value is checked
        | Example: Then the "remember_me" checkbox should be checked
        | Example: And the "remember_me" checkbox is checked
        | at `FeatureContext::assertCheckboxChecked()`

[Then|*] /^the checkbox "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" (?:is|should be) checked$/
        | Checks, that checkbox with specified id|name|label|value is checked
        | Example: Then the "remember_me" checkbox should be checked
        | Example: And the "remember_me" checkbox is checked
        | at `FeatureContext::assertCheckboxChecked()`

[Then|*] /^the "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" checkbox should (?:be unchecked|not be checked)$/
        | Checks, that checkbox with specified id|name|label|value is unchecked
        | Example: Then the "newsletter" checkbox should be unchecked
        | Example: Then the "newsletter" checkbox should not be checked
        | Example: And the "newsletter" checkbox is unchecked
        | at `FeatureContext::assertCheckboxNotChecked()`

[Then|*] /^the "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" checkbox is (?:unchecked|not checked)$/
        | Checks, that checkbox with specified id|name|label|value is unchecked
        | Example: Then the "newsletter" checkbox should be unchecked
        | Example: Then the "newsletter" checkbox should not be checked
        | Example: And the "newsletter" checkbox is unchecked
        | at `FeatureContext::assertCheckboxNotChecked()`

[Then|*] /^the checkbox "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" should (?:be unchecked|not be checked)$/
        | Checks, that checkbox with specified id|name|label|value is unchecked
        | Example: Then the "newsletter" checkbox should be unchecked
        | Example: Then the "newsletter" checkbox should not be checked
        | Example: And the "newsletter" checkbox is unchecked
        | at `FeatureContext::assertCheckboxNotChecked()`

[Then|*] /^the checkbox "(?P&lt;checkbox&gt;(?:[^"]|\\")*)" is (?:unchecked|not checked)$/
        | Checks, that checkbox with specified id|name|label|value is unchecked
        | Example: Then the "newsletter" checkbox should be unchecked
        | Example: Then the "newsletter" checkbox should not be checked
        | Example: And the "newsletter" checkbox is unchecked
        | at `FeatureContext::assertCheckboxNotChecked()`

[Then|*] /^print current URL$/
        | Prints current URL to console.
        | Example: Then print current URL
        | Example: And print current URL
        | at `FeatureContext::printCurrentUrl()`

[Then|*] /^print last response$/
        | Prints last response to console
        | Example: Then print last response
        | Example: And print last response
        | at `FeatureContext::printLastResponse()`

[Then|*] /^show last response$/
        | Opens last response content in browser
        | Example: Then show last response
        | Example: And show last response
        | at `FeatureContext::showLastResponse()`

        </code></pre> </div>


        <br /><br />
    </div><!-- end .col-lg-12 -->
  </div><!-- end .row -->
</div><!-- end .container-fluid -->


<%- include('footer') %>
